<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Runecraft 3D - AI-Powered Open World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .ui-element {
            position: absolute;
            pointer-events: auto;
        }

        /* AI Chat Interface */
        .ai-chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 450px;
            height: 250px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #764ba2;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(118, 75, 162, 0.3);
        }

        .ai-chat-header {
            padding: 10px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 8px 8px 0 0;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-status-indicator {
            width: 10px;
            height: 10px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            color: #fff;
        }

        .ai-message {
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 5px;
            animation: messageSlide 0.3s ease-out;
        }

        @keyframes messageSlide {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .ai-message.system {
            background: rgba(102, 126, 234, 0.2);
            border-left: 3px solid #667eea;
        }

        .ai-message.npc {
            background: rgba(76, 175, 80, 0.2);
            border-left: 3px solid #4caf50;
        }

        .ai-message.quest {
            background: rgba(255, 193, 7, 0.2);
            border-left: 3px solid #ffc107;
        }

        .ai-message.world {
            background: rgba(156, 39, 176, 0.2);
            border-left: 3px solid #9c27b0;
        }

        .ai-message.combat {
            background: rgba(244, 67, 54, 0.2);
            border-left: 3px solid #f44336;
        }

        .ai-chat-input {
            display: flex;
            padding: 10px;
            border-top: 1px solid #333;
        }

        .ai-input-field {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #667eea;
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }

        .ai-send-btn {
            margin-left: 10px;
            padding: 8px 20px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .ai-send-btn:hover {
            transform: scale(1.05);
        }

        .ai-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Minimap */
        .minimap {
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #667eea;
            border-radius: 10px;
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* Stats Panel */
        .stats-panel {
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            min-width: 250px;
        }

        .stat-bar {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            font-size: 12px;
            width: 60px;
            text-shadow: 1px 1px 0 #000;
            font-weight: bold;
        }

        .stat-bar-bg {
            flex: 1;
            height: 22px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 11px;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease-out;
            position: relative;
            border-radius: 10px;
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            z-index: 1;
        }

        .health-fill { 
            background: linear-gradient(90deg, #ef4444, #dc2626);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }
        
        .mana-fill { 
            background: linear-gradient(90deg, #3b82f6, #2563eb);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        .exp-fill { 
            background: linear-gradient(90deg, #f59e0b, #d97706);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }

        /* Inventory */
        .inventory {
            bottom: 280px;
            right: 10px;
            width: 320px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 10px;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(8, 35px);
            gap: 3px;
        }

        .inv-slot {
            width: 35px;
            height: 35px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 20px;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .inv-slot:hover {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.2);
            transform: scale(1.1);
        }

        /* Action Bar */
        .action-bar {
            bottom: 280px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 10px;
        }

        .action-slot {
            width: 60px;
            height: 60px;
            background: rgba(102, 126, 234, 0.2);
            border: 2px solid #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 28px;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .action-slot:hover {
            border-color: #f59e0b;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }

        .hotkey {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 12px;
            color: #f59e0b;
            text-shadow: 1px 1px 0 #000;
            font-weight: bold;
        }

        /* AI Decision Display */
        .ai-decision-panel {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #9c27b0;
            border-radius: 10px;
            padding: 15px;
            color: white;
            min-width: 300px;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translate(-50%, -20px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        .ai-decision-panel.active {
            display: block;
        }

        .ai-decision-title {
            font-size: 16px;
            font-weight: bold;
            color: #9c27b0;
            margin-bottom: 10px;
        }

        .ai-decision-content {
            font-size: 14px;
            line-height: 1.5;
        }

        /* Quest Tracker */
        .quest-tracker {
            top: 220px;
            right: 10px;
            width: 200px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 10px;
            color: #fff;
        }

        .quest-title {
            color: #ffc107;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        .quest-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
            font-size: 11px;
            border-radius: 3px;
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 2000;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .loading-bar {
            width: 400px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 15px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #fff, #f0f0f0);
            width: 0%;
            transition: width 0.5s ease-out;
            border-radius: 13px;
        }

        /* Enemy Health Bar */
        .enemy-health {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -200px);
            background: rgba(0, 0, 0, 0.9);
            padding: 8px;
            border: 2px solid #f44336;
            border-radius: 8px;
            min-width: 250px;
            display: none;
        }

        .enemy-health.active {
            display: block;
        }

        .enemy-name {
            color: #f44336;
            text-align: center;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        /* Damage Numbers */
        .damage-text {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            animation: damageFloat 1.5s ease-out forwards;
        }

        @keyframes damageFloat {
            0% {
                transform: translate(-50%, 0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -60px);
                opacity: 0;
            }
        }

        .damage-player { color: #ef4444; }
        .damage-enemy { color: #fbbf24; }
        .damage-heal { color: #4ade80; }

        /* NPC Dialogue Box */
        .npc-dialogue-box {
            position: absolute;
            bottom: 280px;
            left: 480px;
            width: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4caf50;
            border-radius: 10px;
            padding: 15px;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .npc-dialogue-box.active {
            display: block;
        }

        .npc-name {
            color: #4caf50;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .npc-text {
            color: white;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .dialogue-options {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .dialogue-option {
            padding: 8px 12px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4caf50;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dialogue-option:hover {
            background: rgba(76, 175, 80, 0.4);
            transform: translateX(5px);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <!-- Stats Panel -->
            <div class="stats-panel ui-element">
                <div class="stat-bar">
                    <span class="stat-label">HP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill health-fill" id="healthBar" style="width: 100%">
                            <span class="stat-bar-text" id="healthText">100/100</span>
                        </div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">MP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill mana-fill" id="manaBar" style="width: 100%">
                            <span class="stat-bar-text" id="manaText">50/50</span>
                        </div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">XP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill exp-fill" id="expBar" style="width: 0%">
                            <span class="stat-bar-text" id="expText">0/100</span>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 10px; color: #ffd700; font-size: 14px;">
                    <span>Level: <span id="playerLevel">1</span></span> |
                    <span>Gold: <span id="playerGold">0</span></span>
                </div>
            </div>

            <!-- Minimap -->
            <div class="minimap ui-element">
                <canvas id="minimapCanvas"></canvas>
            </div>

            <!-- Quest Tracker -->
            <div class="quest-tracker ui-element" id="questTracker">
                <div class="quest-title">Active Quests</div>
                <div id="questList"></div>
            </div>

            <!-- Enemy Health Bar -->
            <div class="enemy-health ui-element" id="enemyHealth">
                <div class="enemy-name" id="enemyName">Enemy</div>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill health-fill" id="enemyHealthFill" style="width: 100%"></div>
                </div>
            </div>

            <!-- Action Bar -->
            <div class="action-bar ui-element">
                <div class="action-slot" data-action="attack">
                    <span class="hotkey">1</span>
                    ‚öîÔ∏è
                </div>
                <div class="action-slot" data-action="magic">
                    <span class="hotkey">2</span>
                    üîÆ
                </div>
                <div class="action-slot" data-action="ranged">
                    <span class="hotkey">3</span>
                    üèπ
                </div>
                <div class="action-slot" data-action="heal">
                    <span class="hotkey">4</span>
                    ‚ù§Ô∏è
                </div>
                <div class="action-slot" data-action="special">
                    <span class="hotkey">5</span>
                    ‚ö°
                </div>
            </div>

            <!-- Inventory -->
            <div class="inventory ui-element">
                <div style="color: #fff; margin-bottom: 10px; text-align: center; font-weight: bold;">Inventory</div>
                <div class="inv-grid" id="inventoryGrid"></div>
            </div>

            <!-- AI Chat Interface -->
            <div class="ai-chat-container ui-element">
                <div class="ai-chat-header">
                    <span>AI Game Master</span>
                    <div class="ai-status-indicator"></div>
                </div>
                <div class="ai-chat-messages" id="aiChatMessages"></div>
                <div class="ai-chat-input">
                    <input type="text" class="ai-input-field" id="aiInput" placeholder="Talk to the AI Game Master..." />
                    <button class="ai-send-btn" id="aiSendBtn">Send</button>
                </div>
            </div>

            <!-- AI Decision Panel -->
            <div class="ai-decision-panel ui-element" id="aiDecisionPanel">
                <div class="ai-decision-title">AI World Event</div>
                <div class="ai-decision-content" id="aiDecisionContent"></div>
            </div>

            <!-- NPC Dialogue Box -->
            <div class="npc-dialogue-box ui-element" id="npcDialogueBox">
                <div class="npc-name" id="npcName"></div>
                <div class="npc-text" id="npcText"></div>
                <div class="dialogue-options" id="dialogueOptions"></div>
            </div>
        </div>

        <!-- Loading Screen -->
        <div class="loading" id="loadingScreen">
            <div class="loading-text">Initializing AI World...</div>
            <div class="loading-bar">
                <div class="loading-fill" id="loadingFill"></div>
            </div>
        </div>
    </div>

    <script>
        // AI-Enhanced Runecraft 3D Game
        class AIRunecraft3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');

                // AI Configuration
                this.aiEndpoint = 'https://reimagined-invention-xr5qq9gwp6c9754-7071.app.github.dev/api/businessinsightbot_function';
                this.aiEnabled = true;
                this.userGuid = this.generateUserGuid();
                this.conversationHistory = [];
                this.aiProcessing = false;
                this.worldNarrative = '';
                this.currentPhase = 'early'; // early, mid, late
                this.aiDecisions = [];

                // Set canvas size
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Game state
                this.tileSize = 32;
                this.viewWidth = 25;
                this.viewHeight = 18;
                this.gameTime = 0;
                this.lastTime = 0;
                this.deltaTime = 0;

                // Camera
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 1
                };

                // Player data
                this.player = {
                    x: 50,
                    y: 50,
                    z: 0,
                    targetX: 50,
                    targetY: 50,
                    facing: 'south',
                    moving: false,
                    moveProgress: 0,
                    animFrame: 0,
                    animSpeed: 0.1,
                    level: 1,
                    health: 100,
                    maxHealth: 100,
                    mana: 50,
                    maxMana: 50,
                    exp: 0,
                    expToNext: 100,
                    gold: 100,
                    inventory: [],
                    relationships: {},
                    choices: [],
                    karma: 0
                };

                // World state
                this.worldMap = [];
                this.worldSize = 200;
                this.npcs = [];
                this.enemies = [];
                this.activeQuests = [];
                this.worldEvents = [];
                this.dynamicLocations = [];

                // Game systems
                this.projectiles = [];
                this.effects = [];
                this.lootDrops = [];
                this.particles = [];

                // Input
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };

                // Initialize game
                this.init();
            }

            generateUserGuid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            async init() {
                this.showLoadingProgress(10, 'Generating world...');
                await this.generateAIWorld();
                
                this.showLoadingProgress(30, 'Initializing AI Game Master...');
                await this.initializeAI();
                
                this.showLoadingProgress(50, 'Creating NPCs...');
                await this.spawnAINPCs();
                
                this.showLoadingProgress(70, 'Generating initial quests...');
                await this.generateInitialQuests();
                
                this.showLoadingProgress(90, 'Setting up game systems...');
                this.setupInput();
                this.setupAIChat();
                
                this.showLoadingProgress(100, 'Ready!');
                setTimeout(() => this.hideLoading(), 500);
                
                // Start game loop
                this.gameLoop(0);
                
                // Start AI update cycle
                setInterval(() => this.aiWorldUpdate(), 30000); // Every 30 seconds
                setInterval(() => this.checkPhaseTransition(), 60000); // Every minute
                
                // Initial UI update
                this.updateUI();
                this.renderInventory();
            }

            async generateAIWorld() {
                const width = this.worldSize;
                const height = this.worldSize;
                this.worldMap = [];

                // Use Perlin-like noise for terrain
                const noise = (x, y) => {
                    const scale1 = 0.05;
                    const scale2 = 0.1;
                    return Math.sin(x * scale1) * Math.cos(y * scale1) + 
                           Math.sin(x * scale2) * Math.cos(y * scale2) * 0.5;
                };

                for (let y = 0; y < height; y++) {
                    this.worldMap[y] = [];
                    for (let x = 0; x < width; x++) {
                        const n = noise(x, y);
                        const dist = Math.sqrt(Math.pow(x - width/2, 2) + Math.pow(y - height/2, 2));
                        
                        let biome = 'grasslands';
                        let tile = 'grass';
                        
                        // Biome generation based on noise and distance
                        if (n > 0.5) {
                            biome = 'mountains';
                            tile = 'stone';
                        } else if (n > 0.2) {
                            biome = 'forest';
                            tile = Math.random() < 0.7 ? 'grass' : 'tree';
                        } else if (n > -0.2) {
                            biome = 'grasslands';
                            tile = 'grass';
                        } else if (n > -0.5) {
                            biome = 'desert';
                            tile = 'sand';
                        } else {
                            biome = 'ocean';
                            tile = 'water';
                        }

                        // Add variation
                        if (tile === 'grass' && Math.random() < 0.05) tile = 'flower';
                        if (tile === 'stone' && Math.random() < 0.1) tile = 'rock';
                        
                        this.worldMap[y][x] = {
                            type: tile,
                            biome: biome,
                            height: tile === 'tree' ? 1 : tile === 'rock' ? 0.5 : 0,
                            solid: tile === 'water' || tile === 'tree' || tile === 'rock',
                            discovered: false,
                            aiModified: false
                        };
                    }
                }

                // Create starting area
                const startX = Math.floor(width / 2);
                const startY = Math.floor(height / 2);
                for (let dy = -5; dy <= 5; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            this.worldMap[y][x] = {
                                type: 'stone_floor',
                                biome: 'town',
                                height: 0,
                                solid: false,
                                discovered: true,
                                aiModified: false
                            };
                        }
                    }
                }
            }

            async initializeAI() {
                try {
                    const response = await this.callAI('Initialize game world', 'system');
                    if (response && response.game_data) {
                        const gameData = JSON.parse(response.game_data);
                        if (gameData.world_lore) {
                            this.worldNarrative = gameData.world_lore;
                        }
                    }
                    this.addAIMessage('Welcome to the AI-driven world of Runecraft! Your choices will shape the destiny of this realm.', 'system');
                } catch (error) {
                    console.error('AI initialization error:', error);
                    this.addAIMessage('AI Game Master is ready. The world awaits your actions!', 'system');
                }
            }

            async callAI(message, context = 'player') {
                if (this.aiProcessing || !this.aiEnabled) return null;
                
                this.aiProcessing = true;
                const sendBtn = document.getElementById('aiSendBtn');
                if (sendBtn) sendBtn.disabled = true;

                try {
                    // Prepare context data
                    const contextData = {
                        player: {
                            level: this.player.level,
                            health: this.player.health,
                            location: { x: Math.floor(this.player.x), y: Math.floor(this.player.y) },
                            inventory: this.player.inventory.map(i => i.name),
                            karma: this.player.karma,
                            choices: this.player.choices.slice(-5)
                        },
                        world: {
                            phase: this.currentPhase,
                            time: Math.floor(this.gameTime / 1000),
                            activeQuests: this.activeQuests.map(q => q.name),
                            recentEvents: this.worldEvents.slice(-3)
                        },
                        context: context
                    };

                    // Build conversation history
                    const fullMessage = `[GAME_CONTEXT: ${JSON.stringify(contextData)}]\n${message}`;
                    
                    this.conversationHistory.push({
                        role: 'user',
                        content: fullMessage
                    });

                    // Make AI call
                    const response = await fetch(this.aiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            user_input: fullMessage,
                            conversation_history: this.conversationHistory.slice(-10),
                            user_guid: this.userGuid
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`AI request failed: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Add AI response to history
                    if (data.assistant_response) {
                        this.conversationHistory.push({
                            role: 'assistant',
                            content: data.assistant_response
                        });
                    }

                    return data;
                } catch (error) {
                    console.error('AI call error:', error);
                    return null;
                } finally {
                    this.aiProcessing = false;
                    if (sendBtn) sendBtn.disabled = false;
                }
            }

            async spawnAINPCs() {
                // Generate initial NPCs with AI personalities
                const npcTemplates = [
                    { name: 'Elder Wisdom', type: 'elder', icon: 'üßô', x: 100, y: 100 },
                    { name: 'Mysterious Merchant', type: 'merchant', icon: 'üßë‚Äçüíº', x: 95, y: 100 },
                    { name: 'Guardian Spirit', type: 'guardian', icon: 'üëª', x: 105, y: 100 },
                    { name: 'Wandering Scholar', type: 'scholar', icon: 'üìö', x: 100, y: 95 },
                    { name: 'Shadow Broker', type: 'rogue', icon: 'üó°Ô∏è', x: 100, y: 105 }
                ];

                for (const template of npcTemplates) {
                    const npc = {
                        ...template,
                        id: this.generateUserGuid(),
                        health: 100,
                        dialogue: [],
                        personality: await this.generateNPCPersonality(template.type),
                        relationship: 0,
                        questsGiven: [],
                        aiControlled: true
                    };
                    this.npcs.push(npc);
                }

                // Spawn some initial enemies
                this.spawnDynamicEnemies(10);
            }

            async generateNPCPersonality(type) {
                const personalities = {
                    elder: { wisdom: 90, kindness: 70, mystery: 50 },
                    merchant: { greed: 60, cunning: 70, helpful: 40 },
                    guardian: { protective: 90, stern: 60, loyal: 80 },
                    scholar: { knowledge: 85, curious: 90, social: 30 },
                    rogue: { cunning: 90, trustworthy: 20, opportunistic: 80 }
                };
                return personalities[type] || { neutral: 50 };
            }

            spawnDynamicEnemies(count) {
                const enemyTypes = [
                    { name: 'Corrupted Spirit', icon: 'üëπ', color: '#8b00ff', health: 50, damage: 10 },
                    { name: 'Shadow Beast', icon: 'üê∫', color: '#333', health: 40, damage: 8 },
                    { name: 'Chaos Elemental', icon: 'üî•', color: '#ff4500', health: 60, damage: 12 },
                    { name: 'Void Walker', icon: 'üëæ', color: '#4b0082', health: 70, damage: 15 }
                ];

                for (let i = 0; i < count; i++) {
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * this.worldSize);
                        y = Math.floor(Math.random() * this.worldSize);
                    } while (!this.isValidPosition(x, y) || this.getDistance({x, y}, this.player) < 10);

                    this.enemies.push({
                        ...type,
                        id: this.generateUserGuid(),
                        x: x,
                        y: y,
                        z: 0,
                        maxHealth: type.health,
                        targetX: x,
                        targetY: y,
                        moving: false,
                        moveProgress: 0,
                        behavior: 'patrol',
                        aiControlled: true
                    });
                }
            }

            async generateInitialQuests() {
                const response = await this.callAI('Generate initial quests for the player', 'quest');
                
                if (response && response.game_data) {
                    try {
                        const gameData = JSON.parse(response.game_data);
                        if (gameData.quests) {
                            gameData.quests.forEach(quest => {
                                this.activeQuests.push({
                                    id: this.generateUserGuid(),
                                    name: quest.name || 'Mystery Quest',
                                    description: quest.description || 'Explore the unknown',
                                    objectives: quest.objectives || [],
                                    completed: false,
                                    aiGenerated: true
                                });
                            });
                            this.updateQuestTracker();
                        }
                    } catch (e) {
                        console.error('Failed to parse quest data:', e);
                    }
                }

                // Add a default quest if none were generated
                if (this.activeQuests.length === 0) {
                    this.activeQuests.push({
                        id: this.generateUserGuid(),
                        name: 'The Beginning',
                        description: 'Explore the world and discover your destiny',
                        objectives: [
                            { text: 'Talk to an NPC', completed: false },
                            { text: 'Defeat an enemy', completed: false },
                            { text: 'Find a treasure', completed: false }
                        ],
                        completed: false,
                        aiGenerated: false
                    });
                    this.updateQuestTracker();
                }
            }

            async aiWorldUpdate() {
                if (!this.aiEnabled || this.aiProcessing) return;

                // Request world event from AI
                const response = await this.callAI(
                    `Generate a world event for phase: ${this.currentPhase}`, 
                    'world'
                );

                if (response && response.assistant_response) {
                    this.showAIDecision('World Event', response.assistant_response);
                    
                    // Parse game data for actual changes
                    if (response.game_data) {
                        try {
                            const gameData = JSON.parse(response.game_data);
                            this.processAIWorldChanges(gameData);
                        } catch (e) {
                            console.error('Failed to process AI world changes:', e);
                        }
                    }
                }

                // AI-controlled NPC actions
                this.updateAINPCs();
                
                // Dynamic enemy behavior
                this.updateAIEnemies();
            }

            processAIWorldChanges(gameData) {
                // Process various types of world changes
                if (gameData.spawn_enemies) {
                    this.spawnDynamicEnemies(gameData.spawn_enemies);
                }

                if (gameData.weather) {
                    this.changeWeather(gameData.weather);
                }

                if (gameData.new_location) {
                    this.createDynamicLocation(gameData.new_location);
                }

                if (gameData.world_event) {
                    this.worldEvents.push({
                        time: this.gameTime,
                        event: gameData.world_event
                    });
                }
            }

            createDynamicLocation(locationData) {
                const x = locationData.x || Math.floor(Math.random() * this.worldSize);
                const y = locationData.y || Math.floor(Math.random() * this.worldSize);
                const radius = locationData.radius || 5;

                // Modify terrain around the location
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const tx = x + dx;
                        const ty = y + dy;
                        if (tx >= 0 && tx < this.worldSize && ty >= 0 && ty < this.worldSize) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= radius) {
                                this.worldMap[ty][tx].aiModified = true;
                                if (locationData.type) {
                                    this.worldMap[ty][tx].type = locationData.type;
                                }
                            }
                        }
                    }
                }

                this.dynamicLocations.push({
                    ...locationData,
                    x: x,
                    y: y,
                    created: this.gameTime
                });

                this.addAIMessage(`A new location has appeared: ${locationData.name || 'Mysterious Place'}`, 'world');
            }

            changeWeather(weather) {
                this.currentWeather = weather;
                // Weather effects would be rendered here
                this.addAIMessage(`The weather changes to ${weather}`, 'world');
            }

            updateAINPCs() {
                this.npcs.forEach(npc => {
                    if (!npc.aiControlled) return;

                    // Simple AI behavior
                    const dist = this.getDistance(npc, this.player);
                    
                    if (dist < 15) {
                        // Move randomly when player is nearby
                        if (Math.random() < 0.01) {
                            const dx = (Math.random() - 0.5) * 2;
                            const dy = (Math.random() - 0.5) * 2;
                            const newX = npc.x + dx;
                            const newY = npc.y + dy;
                            
                            if (this.isValidPosition(newX, newY)) {
                                npc.x = newX;
                                npc.y = newY;
                            }
                        }
                    }
                });
            }

            updateAIEnemies() {
                this.enemies.forEach(enemy => {
                    if (!enemy.aiControlled || enemy.health <= 0) return;

                    const dist = this.getDistance(enemy, this.player);
                    
                    if (dist < 8) {
                        // Aggressive behavior when player is near
                        enemy.behavior = 'aggressive';
                        
                        if (dist > 1.5) {
                            // Move towards player
                            const dx = this.player.x - enemy.x;
                            const dy = this.player.y - enemy.y;
                            const magnitude = Math.sqrt(dx * dx + dy * dy);
                            
                            enemy.targetX = enemy.x + (dx / magnitude) * 0.5;
                            enemy.targetY = enemy.y + (dy / magnitude) * 0.5;
                            enemy.moving = true;
                        }
                    } else {
                        // Patrol behavior
                        enemy.behavior = 'patrol';
                        
                        if (Math.random() < 0.02) {
                            const angle = Math.random() * Math.PI * 2;
                            enemy.targetX = enemy.x + Math.cos(angle) * 2;
                            enemy.targetY = enemy.y + Math.sin(angle) * 2;
                            enemy.moving = true;
                        }
                    }
                });
            }

            checkPhaseTransition() {
                const totalExp = this.player.exp;
                const timeElapsed = this.gameTime / 1000 / 60; // Minutes
                
                let newPhase = this.currentPhase;
                
                if (totalExp > 5000 || timeElapsed > 30) {
                    newPhase = 'late';
                } else if (totalExp > 1000 || timeElapsed > 10) {
                    newPhase = 'mid';
                }
                
                if (newPhase !== this.currentPhase) {
                    this.currentPhase = newPhase;
                    this.triggerPhaseTransition(newPhase);
                }
            }

            async triggerPhaseTransition(phase) {
                const response = await this.callAI(
                    `The game has transitioned to ${phase} phase. Generate a major story event.`,
                    'story'
                );

                if (response && response.assistant_response) {
                    this.showAIDecision(`Phase Transition: ${phase.toUpperCase()}`, response.assistant_response);
                    this.addAIMessage(`The world has entered the ${phase} phase!`, 'system');
                }

                // Spawn more challenging enemies in later phases
                if (phase === 'mid') {
                    this.spawnDynamicEnemies(15);
                } else if (phase === 'late') {
                    this.spawnDynamicEnemies(25);
                    // Spawn boss
                    this.spawnBoss();
                }
            }

            spawnBoss() {
                const boss = {
                    name: 'The Void Lord',
                    icon: 'üé≠',
                    color: '#ff00ff',
                    health: 500,
                    maxHealth: 500,
                    damage: 30,
                    x: Math.floor(this.worldSize / 2) + 20,
                    y: Math.floor(this.worldSize / 2) + 20,
                    z: 0,
                    isBoss: true,
                    aiControlled: true,
                    behavior: 'boss'
                };
                this.enemies.push(boss);
                this.addAIMessage('A powerful boss has emerged! The Void Lord awaits...', 'world');
            }

            setupInput() {
                // Mouse controls
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleKeyPress(e.key.toLowerCase());
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Action bar clicks
                document.querySelectorAll('.action-slot').forEach(slot => {
                    slot.addEventListener('click', () => {
                        const action = slot.dataset.action;
                        this.useAbility(action);
                    });
                });
            }

            setupAIChat() {
                const input = document.getElementById('aiInput');
                const sendBtn = document.getElementById('aiSendBtn');

                const sendMessage = async () => {
                    const message = input.value.trim();
                    if (!message || this.aiProcessing) return;

                    input.value = '';
                    this.addAIMessage(message, 'player');

                    const response = await this.callAI(message, 'chat');
                    if (response && response.assistant_response) {
                        this.addAIMessage(response.assistant_response, 'system');
                        
                        // Process any game data changes
                        if (response.game_data) {
                            try {
                                const gameData = JSON.parse(response.game_data);
                                this.processAIGameData(gameData);
                            } catch (e) {
                                console.error('Failed to process game data:', e);
                            }
                        }
                    }
                };

                sendBtn.addEventListener('click', sendMessage);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendMessage();
                    }
                });
            }

            processAIGameData(gameData) {
                if (gameData.give_item) {
                    this.player.inventory.push({
                        name: gameData.give_item,
                        icon: 'üéÅ',
                        type: 'special'
                    });
                    this.renderInventory();
                    this.addAIMessage(`You received: ${gameData.give_item}`, 'loot');
                }

                if (gameData.new_quest) {
                    this.activeQuests.push({
                        id: this.generateUserGuid(),
                        name: gameData.new_quest.name,
                        description: gameData.new_quest.description,
                        objectives: gameData.new_quest.objectives || [],
                        completed: false,
                        aiGenerated: true
                    });
                    this.updateQuestTracker();
                }

                if (gameData.karma_change) {
                    this.player.karma += gameData.karma_change;
                    const karmaText = gameData.karma_change > 0 ? 'increased' : 'decreased';
                    this.addAIMessage(`Your karma has ${karmaText}`, 'system');
                }
            }

            addAIMessage(text, type = 'system') {
                const container = document.getElementById('aiChatMessages');
                const message = document.createElement('div');
                message.className = `ai-message ${type}`;
                
                const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                message.innerHTML = `<span style="opacity: 0.7">[${timestamp}]</span> ${text}`;
                
                container.appendChild(message);
                container.scrollTop = container.scrollHeight;

                // Limit messages
                while (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
            }

            showAIDecision(title, content) {
                const panel = document.getElementById('aiDecisionPanel');
                const contentDiv = document.getElementById('aiDecisionContent');
                
                document.querySelector('.ai-decision-title').textContent = title;
                contentDiv.textContent = content;
                
                panel.classList.add('active');
                
                setTimeout(() => {
                    panel.classList.remove('active');
                }, 5000);
            }

            async handleNPCInteraction(npc) {
                const dialogueBox = document.getElementById('npcDialogueBox');
                const npcNameDiv = document.getElementById('npcName');
                const npcTextDiv = document.getElementById('npcText');
                const optionsDiv = document.getElementById('dialogueOptions');

                npcNameDiv.textContent = npc.name;
                npcTextDiv.textContent = 'Thinking...';
                optionsDiv.innerHTML = '';
                dialogueBox.classList.add('active');

                // Get AI-generated dialogue
                const response = await this.callAI(
                    `Player interacts with ${npc.name} (${npc.type})`,
                    'npc'
                );

                if (response && response.assistant_response) {
                    npcTextDiv.textContent = response.assistant_response;
                    
                    // Generate dialogue options
                    const options = [
                        'Tell me more',
                        'Do you have any quests?',
                        'Goodbye'
                    ];
                    
                    options.forEach(option => {
                        const btn = document.createElement('div');
                        btn.className = 'dialogue-option';
                        btn.textContent = option;
                        btn.addEventListener('click', () => {
                            this.handleDialogueChoice(npc, option);
                        });
                        optionsDiv.appendChild(btn);
                    });
                } else {
                    npcTextDiv.textContent = `Hello, traveler. I am ${npc.name}.`;
                }
            }

            async handleDialogueChoice(npc, choice) {
                if (choice === 'Goodbye') {
                    document.getElementById('npcDialogueBox').classList.remove('active');
                    return;
                }

                const response = await this.callAI(
                    `Player says to ${npc.name}: "${choice}"`,
                    'npc'
                );

                if (response && response.assistant_response) {
                    document.getElementById('npcText').textContent = response.assistant_response;
                }

                // Update relationship
                npc.relationship = (npc.relationship || 0) + 1;
                this.player.relationships[npc.id] = npc.relationship;
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const worldPos = this.screenToWorld(x, y);

                // Check for NPC interaction
                const npc = this.getNPCAt(worldPos.x, worldPos.y);
                if (npc) {
                    this.handleNPCInteraction(npc);
                    return;
                }

                // Check for enemy
                const enemy = this.getEnemyAt(worldPos.x, worldPos.y);
                if (enemy) {
                    this.targetEnemy(enemy);
                    return;
                }

                // Check for loot
                const loot = this.getLootAt(worldPos.x, worldPos.y);
                if (loot) {
                    this.pickupLoot(loot);
                    return;
                }

                // Move player
                this.movePlayer(worldPos.x, worldPos.y);
            }

            handleKeyPress(key) {
                switch(key) {
                    case '1': this.useAbility('attack'); break;
                    case '2': this.useAbility('magic'); break;
                    case '3': this.useAbility('ranged'); break;
                    case '4': this.useAbility('heal'); break;
                    case '5': this.useAbility('special'); break;
                    case 'i': this.toggleInventory(); break;
                }
            }

            screenToWorld(screenX, screenY) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                const isoX = (screenX - centerX) / this.tileSize;
                const isoY = (screenY - centerY) / (this.tileSize * 0.5);

                const worldX = (isoX + isoY) / 2 + this.camera.x;
                const worldY = (isoY - isoX) / 2 + this.camera.y;

                return {
                    x: Math.floor(worldX + this.player.x),
                    y: Math.floor(worldY + this.player.y)
                };
            }

            worldToScreen(worldX, worldY, worldZ = 0) {
                const relX = worldX - this.player.x - this.camera.x;
                const relY = worldY - this.player.y - this.camera.y;

                const isoX = (relX - relY) * this.tileSize;
                const isoY = (relX + relY) * this.tileSize * 0.5 - worldZ * this.tileSize;

                return {
                    x: this.canvas.width / 2 + isoX,
                    y: this.canvas.height / 2 + isoY
                };
            }

            movePlayer(targetX, targetY) {
                if (this.player.moving) return;

                if (!this.isValidPosition(targetX, targetY)) return;

                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) return;

                this.player.targetX = targetX;
                this.player.targetY = targetY;
                this.player.moving = true;
                this.player.moveProgress = 0;

                // Update facing
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.player.facing = dx > 0 ? 'east' : 'west';
                } else {
                    this.player.facing = dy > 0 ? 'south' : 'north';
                }

                // Record player movement choice
                this.player.choices.push({
                    type: 'move',
                    target: { x: targetX, y: targetY },
                    time: this.gameTime
                });
            }

            isValidPosition(x, y) {
                if (x < 0 || y < 0 || x >= this.worldSize || y >= this.worldSize) {
                    return false;
                }
                return !this.worldMap[Math.floor(y)][Math.floor(x)].solid;
            }

            getNPCAt(x, y) {
                return this.npcs.find(n =>
                    Math.floor(n.x) === x && Math.floor(n.y) === y
                );
            }

            getEnemyAt(x, y) {
                return this.enemies.find(e =>
                    Math.floor(e.x) === x && Math.floor(e.y) === y && e.health > 0
                );
            }

            getLootAt(x, y) {
                return this.lootDrops.find(l =>
                    Math.floor(l.x) === x && Math.floor(l.y) === y
                );
            }

            targetEnemy(enemy) {
                this.player.target = enemy;
                
                document.getElementById('enemyHealth').classList.add('active');
                document.getElementById('enemyName').textContent = enemy.name;

                const dist = this.getDistance(this.player, enemy);
                if (dist > 1.5) {
                    this.movePlayer(Math.floor(enemy.x), Math.floor(enemy.y));
                } else {
                    this.attackEnemy(enemy);
                }
            }

            async attackEnemy(enemy, type = 'melee') {
                if (!enemy || enemy.health <= 0) return;

                const dist = this.getDistance(this.player, enemy);
                const maxRange = type === 'ranged' ? 8 : type === 'magic' ? 6 : 1.5;
                
                if (dist > maxRange) {
                    this.addAIMessage('Target is too far away!', 'combat');
                    return;
                }

                let damage = Math.floor(Math.random() * 15) + 5 + this.player.level;
                
                if (type === 'magic' && this.player.mana >= 5) {
                    this.player.mana -= 5;
                    damage *= 1.5;
                }

                enemy.health -= damage;
                this.showDamageText(enemy.x, enemy.y, damage, 'damage-enemy');

                if (enemy.health <= 0) {
                    await this.enemyDefeated(enemy);
                } else {
                    setTimeout(() => this.enemyAttack(enemy), 1000);
                }

                this.updateUI();

                // Record combat choice
                this.player.choices.push({
                    type: 'combat',
                    action: 'attack',
                    target: enemy.name,
                    damage: damage,
                    time: this.gameTime
                });
            }

            enemyAttack(enemy) {
                if (!enemy || enemy.health <= 0) return;
                if (this.getDistance(this.player, enemy) > 2) return;

                const damage = Math.floor(Math.random() * (enemy.damage || 10)) + 1;
                this.player.health -= damage;
                this.showDamageText(this.player.x, this.player.y, damage, 'damage-player');

                if (this.player.health <= 0) {
                    this.playerDeath();
                }

                this.updateUI();
            }

            async enemyDefeated(enemy) {
                const exp = enemy.health * 2;
                const gold = Math.floor(Math.random() * 50) + 10;

                this.player.exp += exp;
                this.player.gold += gold;

                this.addAIMessage(`Defeated ${enemy.name}! +${exp} XP, +${gold} gold`, 'combat');

                // AI determines loot
                const response = await this.callAI(
                    `Player defeated ${enemy.name}. What loot should drop?`,
                    'loot'
                );

                if (response && response.game_data) {
                    try {
                        const gameData = JSON.parse(response.game_data);
                        if (gameData.loot) {
                            this.dropLoot(enemy.x, enemy.y, gameData.loot);
                        }
                    } catch (e) {
                        // Default loot
                        this.dropLoot(enemy.x, enemy.y, null);
                    }
                } else {
                    this.dropLoot(enemy.x, enemy.y, null);
                }

                // Remove enemy
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }

                document.getElementById('enemyHealth').classList.remove('active');
                this.player.target = null;

                // Update quest progress
                this.updateQuestProgress('defeat', enemy.name);

                // Check level up
                this.checkLevelUp();

                // Karma adjustment based on enemy type
                if (enemy.name.includes('Corrupted')) {
                    this.player.karma += 1;
                }
            }

            dropLoot(x, y, lootData) {
                const defaultLoot = {
                    name: 'Mystery Item',
                    icon: 'üì¶',
                    type: 'item'
                };

                const loot = lootData || defaultLoot;

                this.lootDrops.push({
                    x: x,
                    y: y,
                    z: 0,
                    item: loot,
                    bounce: 1
                });
            }

            pickupLoot(loot) {
                if (this.getDistance(this.player, loot) > 1.5) {
                    this.movePlayer(Math.floor(loot.x), Math.floor(loot.y));
                    return;
                }

                if (this.player.inventory.length < 28) {
                    this.player.inventory.push(loot.item);
                    this.addAIMessage(`Picked up ${loot.item.name}`, 'loot');

                    const index = this.lootDrops.indexOf(loot);
                    if (index > -1) {
                        this.lootDrops.splice(index, 1);
                    }

                    this.renderInventory();
                    
                    // Update quest progress
                    this.updateQuestProgress('collect', loot.item.name);
                } else {
                    this.addAIMessage('Inventory full!', 'system');
                }
            }

            useAbility(ability) {
                if (!this.player.target && ability !== 'heal') {
                    this.addAIMessage('No target selected!', 'combat');
                    return;
                }

                switch(ability) {
                    case 'attack':
                        this.attackEnemy(this.player.target, 'melee');
                        break;
                    case 'magic':
                        this.attackEnemy(this.player.target, 'magic');
                        break;
                    case 'ranged':
                        this.attackEnemy(this.player.target, 'ranged');
                        break;
                    case 'heal':
                        this.healPlayer();
                        break;
                    case 'special':
                        this.specialAttack();
                        break;
                }
            }

            healPlayer() {
                if (this.player.mana < 10) {
                    this.addAIMessage('Not enough mana!', 'combat');
                    return;
                }

                const healAmount = Math.min(20, this.player.maxHealth - this.player.health);
                if (healAmount <= 0) {
                    this.addAIMessage('Already at full health!', 'system');
                    return;
                }

                this.player.mana -= 10;
                this.player.health += healAmount;
                this.showDamageText(this.player.x, this.player.y, `+${healAmount}`, 'damage-heal');
                this.addAIMessage(`Healed ${healAmount} HP`, 'system');
                this.updateUI();
            }

            async specialAttack() {
                if (this.player.mana < 20) {
                    this.addAIMessage('Not enough mana!', 'combat');
                    return;
                }

                this.player.mana -= 20;

                // AI determines special attack effect
                const response = await this.callAI(
                    'Player uses special attack. Describe the effect.',
                    'combat'
                );

                let description = 'A powerful magical explosion erupts!';
                if (response && response.assistant_response) {
                    description = response.assistant_response;
                }

                this.addAIMessage(description, 'combat');

                // Area damage
                this.enemies.forEach(enemy => {
                    if (this.getDistance(this.player, enemy) < 5) {
                        const damage = Math.floor(Math.random() * 30) + 20;
                        enemy.health -= damage;
                        this.showDamageText(enemy.x, enemy.y, damage, 'damage-enemy');

                        if (enemy.health <= 0) {
                            this.enemyDefeated(enemy);
                        }
                    }
                });

                // Visual effect
                this.effects.push({
                    x: this.player.x,
                    y: this.player.y,
                    type: 'explosion',
                    frame: 0
                });

                this.updateUI();
            }

            getDistance(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            showDamageText(x, y, text, className) {
                const pos = this.worldToScreen(x, y, 0.5);
                const elem = document.createElement('div');
                elem.className = `damage-text ${className}`;
                elem.textContent = text;
                elem.style.left = pos.x + 'px';
                elem.style.top = pos.y + 'px';
                document.querySelector('.ui-overlay').appendChild(elem);

                setTimeout(() => elem.remove(), 1500);
            }

            updateQuestProgress(action, target) {
                this.activeQuests.forEach(quest => {
                    if (quest.completed) return;

                    quest.objectives?.forEach(obj => {
                        if (obj.completed) return;

                        if (action === 'defeat' && obj.text?.includes('Defeat')) {
                            obj.completed = true;
                        } else if (action === 'collect' && obj.text?.includes('Find')) {
                            obj.completed = true;
                        } else if (action === 'talk' && obj.text?.includes('Talk')) {
                            obj.completed = true;
                        }
                    });

                    // Check if quest is complete
                    const allComplete = quest.objectives?.every(obj => obj.completed);
                    if (allComplete && !quest.completed) {
                        quest.completed = true;
                        this.completeQuest(quest);
                    }
                });

                this.updateQuestTracker();
            }

            async completeQuest(quest) {
                this.addAIMessage(`Quest completed: ${quest.name}!`, 'quest');
                
                // AI determines rewards
                const response = await this.callAI(
                    `Player completed quest: ${quest.name}. What rewards should they receive?`,
                    'quest'
                );

                if (response && response.game_data) {
                    try {
                        const gameData = JSON.parse(response.game_data);
                        if (gameData.rewards) {
                            this.processQuestRewards(gameData.rewards);
                        }
                    } catch (e) {
                        // Default rewards
                        this.player.exp += 100;
                        this.player.gold += 50;
                    }
                } else {
                    this.player.exp += 100;
                    this.player.gold += 50;
                }

                this.checkLevelUp();
            }

            processQuestRewards(rewards) {
                if (rewards.exp) {
                    this.player.exp += rewards.exp;
                    this.addAIMessage(`Gained ${rewards.exp} experience!`, 'quest');
                }
                if (rewards.gold) {
                    this.player.gold += rewards.gold;
                    this.addAIMessage(`Received ${rewards.gold} gold!`, 'quest');
                }
                if (rewards.items) {
                    rewards.items.forEach(item => {
                        this.player.inventory.push({
                            name: item,
                            icon: 'üéÅ',
                            type: 'quest'
                        });
                    });
                    this.renderInventory();
                }
            }

            checkLevelUp() {
                while (this.player.exp >= this.player.expToNext) {
                    this.player.level++;
                    this.player.exp -= this.player.expToNext;
                    this.player.expToNext = Math.floor(this.player.expToNext * 1.5);

                    this.player.maxHealth += 10;
                    this.player.health = this.player.maxHealth;
                    this.player.maxMana += 5;
                    this.player.mana = this.player.maxMana;

                    this.addAIMessage(`LEVEL UP! You are now level ${this.player.level}!`, 'system');
                    
                    // AI narrative for level up
                    this.callAI(`Player reached level ${this.player.level}`, 'level').then(response => {
                        if (response && response.assistant_response) {
                            this.addAIMessage(response.assistant_response, 'system');
                        }
                    });
                }

                this.updateUI();
            }

            playerDeath() {
                this.player.health = this.player.maxHealth;
                this.player.x = this.worldSize / 2;
                this.player.y = this.worldSize / 2;
                this.player.gold = Math.max(0, this.player.gold - Math.floor(this.player.gold * 0.1));

                this.addAIMessage('You have fallen! Respawning at the starting point...', 'combat');
                
                // AI narrative for death
                this.callAI('Player died and respawned', 'death').then(response => {
                    if (response && response.assistant_response) {
                        this.addAIMessage(response.assistant_response, 'system');
                    }
                });

                document.getElementById('enemyHealth').classList.remove('active');
                this.player.target = null;

                this.updateUI();
            }

            update(deltaTime) {
                // Update player movement
                if (this.player.moving) {
                    this.player.moveProgress += deltaTime * 0.005;

                    if (this.player.moveProgress >= 1) {
                        this.player.x = this.player.targetX;
                        this.player.y = this.player.targetY;
                        this.player.moving = false;
                        this.player.moveProgress = 0;

                        // Check for location discovery
                        const tile = this.worldMap[Math.floor(this.player.y)][Math.floor(this.player.x)];
                        if (!tile.discovered) {
                            tile.discovered = true;
                            
                            // AI might generate something for new discoveries
                            if (Math.random() < 0.1) {
                                this.callAI(`Player discovered new area in ${tile.biome}`, 'exploration');
                            }
                        }

                        // Attack if we reached enemy
                        if (this.player.target) {
                            const dist = this.getDistance(this.player, this.player.target);
                            if (dist <= 1.5) {
                                this.attackEnemy(this.player.target);
                            }
                        }
                    } else {
                        // Interpolate position
                        const t = this.easeInOutQuad(this.player.moveProgress);
                        const startX = this.player.x - (this.player.targetX - this.player.x) * (1 - t);
                        const startY = this.player.y - (this.player.targetY - this.player.y) * (1 - t);

                        this.player.x = startX + (this.player.targetX - startX) * t;
                        this.player.y = startY + (this.player.targetY - startY) * t;
                    }
                }

                // Update player animation
                this.player.animFrame += this.player.animSpeed * deltaTime;
                if (this.player.animFrame >= 4) this.player.animFrame = 0;

                // Update enemies
                this.enemies.forEach(enemy => {
                    if (enemy.moving && enemy.health > 0) {
                        enemy.moveProgress = (enemy.moveProgress || 0) + deltaTime * 0.003;

                        if (enemy.moveProgress >= 1) {
                            enemy.x = enemy.targetX;
                            enemy.y = enemy.targetY;
                            enemy.moving = false;
                            enemy.moveProgress = 0;
                        } else {
                            const t = this.easeInOutQuad(enemy.moveProgress);
                            enemy.x += (enemy.targetX - enemy.x) * t * 0.1;
                            enemy.y += (enemy.targetY - enemy.y) * t * 0.1;
                        }
                    }
                });

                // Update projectiles
                this.projectiles.forEach((proj, index) => {
                    proj.progress += 0.05;
                    if (proj.progress >= 1) {
                        this.projectiles.splice(index, 1);
                    }
                });

                // Update effects
                this.effects.forEach((effect, index) => {
                    effect.frame++;
                    if (effect.frame > 30) {
                        this.effects.splice(index, 1);
                    }
                });

                // Update loot animation
                this.lootDrops.forEach(loot => {
                    loot.bounce *= 0.98;
                    loot.z = Math.abs(Math.sin(this.gameTime * 0.003)) * 0.2 * loot.bounce;
                });

                // Update enemy health bar
                if (this.player.target && this.player.target.health > 0) {
                    const healthPercent = (this.player.target.health / this.player.target.maxHealth) * 100;
                    document.getElementById('enemyHealthFill').style.width = healthPercent + '%';
                } else if (this.player.target) {
                    document.getElementById('enemyHealth').classList.remove('active');
                    this.player.target = null;
                }

                // Regeneration
                if (this.gameTime % 2000 < deltaTime) {
                    if (this.player.health < this.player.maxHealth) {
                        this.player.health = Math.min(this.player.health + 1, this.player.maxHealth);
                    }
                    if (this.player.mana < this.player.maxMana) {
                        this.player.mana = Math.min(this.player.mana + 2, this.player.maxMana);
                    }
                    this.updateUI();
                }
            }

            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            render() {
                // Clear canvas
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#16213e');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Calculate visible tiles
                const startX = Math.floor(this.player.x - this.viewWidth / 2);
                const endX = Math.ceil(this.player.x + this.viewWidth / 2);
                const startY = Math.floor(this.player.y - this.viewHeight / 2);
                const endY = Math.ceil(this.player.y + this.viewHeight / 2);

                // Render tiles
                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        if (y >= 0 && y < this.worldSize && x >= 0 && x < this.worldSize) {
                            const tile = this.worldMap[y][x];
                            this.renderTile(x, y, tile);
                        }
                    }
                }

                // Render entities in correct order
                const entities = [
                    ...this.lootDrops.map(l => ({...l, type: 'loot'})),
                    ...this.npcs.map(n => ({...n, type: 'npc'})),
                    ...this.enemies.map(e => ({...e, type: 'enemy'})),
                    ...this.projectiles.map(p => ({...p, type: 'projectile'})),
                    {x: this.player.x, y: this.player.y, z: 0, type: 'player'}
                ];

                // Sort by Y position for correct rendering order
                entities.sort((a, b) => {
                    const orderA = a.y + a.x * 0.01;
                    const orderB = b.y + b.x * 0.01;
                    return orderA - orderB;
                });

                // Render entities
                entities.forEach(entity => {
                    if (entity.type === 'player') {
                        this.renderPlayer();
                    } else if (entity.type === 'npc') {
                        this.renderNPC(entity);
                    } else if (entity.type === 'enemy' && entity.health > 0) {
                        this.renderEnemy(entity);
                    } else if (entity.type === 'loot') {
                        this.renderLoot(entity);
                    } else if (entity.type === 'projectile') {
                        this.renderProjectile(entity);
                    }
                });

                // Render effects
                this.effects.forEach(effect => {
                    this.renderEffect(effect);
                });

                // Render dynamic locations
                this.dynamicLocations.forEach(loc => {
                    this.renderDynamicLocation(loc);
                });

                // Render minimap
                this.renderMinimap();
            }

            renderTile(x, y, tile) {
                const pos = this.worldToScreen(x, y, 0);

                const colors = {
                    grass: '#4a7c4e',
                    grass2: '#3d6640',
                    flower: '#6a8c6e',
                    dirt: '#8b7355',
                    stone: '#808080',
                    stone_floor: '#666666',
                    sand: '#f4e4a1',
                    water: '#4682b4',
                    tree: '#228b22',
                    rock: '#696969',
                    lava: '#ff4500',
                    ice: '#b0e0e6',
                    snow: '#ffffff'
                };

                let tileColor = colors[tile.type] || '#333';
                
                // Modify color if AI has changed this tile
                if (tile.aiModified) {
                    tileColor = this.shiftColor(tileColor, 30);
                }

                // Fog of war effect for undiscovered tiles
                if (!tile.discovered) {
                    tileColor = this.darkenColor(tileColor, 0.5);
                }

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Draw diamond shape (isometric square)
                this.ctx.beginPath();
                this.ctx.moveTo(0, -this.tileSize * 0.5);
                this.ctx.lineTo(this.tileSize, 0);
                this.ctx.lineTo(0, this.tileSize * 0.5);
                this.ctx.lineTo(-this.tileSize, 0);
                this.ctx.closePath();

                this.ctx.fillStyle = tileColor;
                this.ctx.fill();

                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                // Draw height objects
                if (tile.height > 0) {
                    if (tile.type === 'tree') {
                        // Tree trunk
                        this.ctx.fillStyle = '#654321';
                        this.ctx.fillRect(-5, -tile.height * this.tileSize - 10, 10, tile.height * this.tileSize);

                        // Tree crown
                        this.ctx.fillStyle = tile.discovered ? '#228b22' : '#1a4a1a';
                        this.ctx.beginPath();
                        this.ctx.arc(0, -tile.height * this.tileSize - 15, 15, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else if (tile.type === 'rock') {
                        this.ctx.fillStyle = tile.discovered ? '#5a5a5a' : '#3a3a3a';
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, -tile.height * this.tileSize * 0.5, 12, 8, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                this.ctx.restore();
            }

            renderPlayer() {
                const pos = this.worldToScreen(this.player.x, this.player.y, 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 5, 12, 6, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Player body with gradient
                const bodyGradient = this.ctx.createLinearGradient(-8, -30, 8, 0);
                bodyGradient.addColorStop(0, '#667eea');
                bodyGradient.addColorStop(1, '#764ba2');
                this.ctx.fillStyle = bodyGradient;
                this.ctx.fillRect(-8, -30, 16, 20);

                // Head
                this.ctx.fillStyle = '#fdbcb4';
                this.ctx.beginPath();
                this.ctx.arc(0, -35, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // Legs
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(-5, -10, 4, 10);
                this.ctx.fillRect(1, -10, 4, 10);

                // Level indicator
                this.ctx.fillStyle = '#ffd700';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`Lv ${this.player.level}`, 0, -45);

                // Karma indicator
                if (this.player.karma !== 0) {
                    const karmaColor = this.player.karma > 0 ? '#4ade80' : '#ef4444';
                    this.ctx.fillStyle = karmaColor;
                    this.ctx.fillText(this.player.karma > 0 ? '‚òÄ' : '‚òæ', 15, -35);
                }

                this.ctx.restore();
            }

            renderNPC(npc) {
                const pos = this.worldToScreen(npc.x, npc.y, 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 5, 10, 5, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // NPC body
                this.ctx.fillStyle = '#4caf50';
                this.ctx.fillRect(-8, -25, 16, 25);

                // Icon
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(npc.icon, 0, -5);

                // Name
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Arial';
                this.ctx.fillText(npc.name, 0, -35);

                // Quest indicator
                const hasQuest = this.activeQuests.some(q => !q.completed && q.giver === npc.id);
                if (hasQuest) {
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText('!', 0, -45);
                }

                // Relationship indicator
                if (npc.relationship > 0) {
                    const hearts = Math.min(Math.floor(npc.relationship / 10), 5);
                    this.ctx.fillStyle = '#ff69b4';
                    this.ctx.font = '8px Arial';
                    this.ctx.fillText('‚ô•'.repeat(hearts), 0, -50);
                }

                this.ctx.restore();
            }

            renderEnemy(enemy) {
                const pos = this.worldToScreen(enemy.x, enemy.y, enemy.z || 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 5, enemy.isBoss ? 15 : 10, enemy.isBoss ? 8 : 5, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Enemy body
                const size = enemy.isBoss ? 1.5 : 1;
                this.ctx.fillStyle = enemy.color;
                this.ctx.fillRect(-10 * size, -25 * size, 20 * size, 25 * size);

                // Glow effect for boss
                if (enemy.isBoss) {
                    this.ctx.shadowColor = enemy.color;
                    this.ctx.shadowBlur = 20;
                }

                // Icon
                this.ctx.font = `${enemy.isBoss ? 30 : 20}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(enemy.icon, 0, -5 * size);

                this.ctx.shadowBlur = 0;

                // Name
                this.ctx.fillStyle = enemy.isBoss ? '#ff00ff' : '#fff';
                this.ctx.font = `${enemy.isBoss ? 12 : 10}px Arial`;
                this.ctx.fillText(enemy.name, 0, -35 * size);

                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const healthPercent = enemy.health / enemy.maxHealth;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(-20, -45 * size, 40, 4);

                    const healthColor = healthPercent > 0.5 ? '#4ade80' : 
                                       healthPercent > 0.25 ? '#fbbf24' : '#ef4444';
                    this.ctx.fillStyle = healthColor;
                    this.ctx.fillRect(-20, -45 * size, 40 * healthPercent, 4);
                }

                this.ctx.restore();
            }

            renderLoot(loot) {
                const pos = this.worldToScreen(loot.x, loot.y, loot.z || 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Glow effect
                this.ctx.shadowColor = '#ffd700';
                this.ctx.shadowBlur = 15;

                // Item icon
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(loot.item.icon || 'üì¶', 0, 0);

                this.ctx.restore();
            }

            renderProjectile(proj) {
                const pos = this.worldToScreen(proj.x, proj.y, proj.z || 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                this.ctx.fillStyle = '#00ffff';
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 10;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 5, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.restore();
            }

            renderEffect(effect) {
                const pos = this.worldToScreen(effect.x, effect.y, 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                if (effect.type === 'explosion') {
                    const radius = effect.frame * 3;
                    const opacity = 1 - (effect.frame / 30);

                    this.ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    this.ctx.stroke();

                    // Inner circle
                    this.ctx.strokeStyle = `rgba(255, 200, 0, ${opacity * 0.5})`;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            }

            renderDynamicLocation(loc) {
                if (Math.abs(loc.x - this.player.x) > this.viewWidth ||
                    Math.abs(loc.y - this.player.y) > this.viewHeight) {
                    return;
                }

                const pos = this.worldToScreen(loc.x, loc.y, 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Pulsing effect for dynamic locations
                const pulse = Math.sin(this.gameTime * 0.003) * 0.5 + 0.5;
                
                this.ctx.fillStyle = `rgba(147, 51, 234, ${pulse * 0.5})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 30, 0, Math.PI * 2);
                this.ctx.fill();

                // Icon
                this.ctx.font = '30px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(loc.icon || 'üåü', 0, 0);

                this.ctx.restore();
            }

            renderMinimap() {
                const scale = 2;
                const width = 200;
                const height = 200;

                // Clear minimap
                this.minimapCtx.fillStyle = '#111';
                this.minimapCtx.fillRect(0, 0, width, height);

                const centerX = width / 2;
                const centerY = height / 2;

                // Render terrain
                for (let y = -50; y <= 50; y += 2) {
                    for (let x = -50; x <= 50; x += 2) {
                        const mapX = Math.floor(this.player.x + x);
                        const mapY = Math.floor(this.player.y + y);

                        if (mapX >= 0 && mapY >= 0 && mapY < this.worldSize && mapX < this.worldSize) {
                            const tile = this.worldMap[mapY][mapX];

                            if (tile.discovered) {
                                const colors = {
                                    grass: '#2d4a2f',
                                    water: '#2a5a7a',
                                    stone: '#404040',
                                    sand: '#8a7a41',
                                    tree: '#1a5a1a',
                                    stone_floor: '#333'
                                };

                                this.minimapCtx.fillStyle = colors[tile.type] || '#222';
                            } else {
                                this.minimapCtx.fillStyle = '#0a0a0a';
                            }

                            this.minimapCtx.fillRect(
                                centerX + x * scale,
                                centerY + y * scale,
                                scale * 2,
                                scale * 2
                            );
                        }
                    }
                }

                // Draw enemies
                this.enemies.forEach(enemy => {
                    if (enemy.health <= 0) return;
                    const dx = enemy.x - this.player.x;
                    const dy = enemy.y - this.player.y;
                    if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                        this.minimapCtx.fillStyle = enemy.isBoss ? '#ff00ff' : '#ff4444';
                        this.minimapCtx.fillRect(
                            centerX + dx * scale - 2,
                            centerY + dy * scale - 2,
                            4,
                            4
                        );
                    }
                });

                // Draw NPCs
                this.npcs.forEach(npc => {
                    const dx = npc.x - this.player.x;
                    const dy = npc.y - this.player.y;
                    if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                        this.minimapCtx.fillStyle = '#4caf50';
                        this.minimapCtx.fillRect(
                            centerX + dx * scale - 2,
                            centerY + dy * scale - 2,
                            4,
                            4
                        );
                    }
                });

                // Draw dynamic locations
                this.dynamicLocations.forEach(loc => {
                    const dx = loc.x - this.player.x;
                    const dy = loc.y - this.player.y;
                    if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                        this.minimapCtx.fillStyle = '#9333ea';
                        this.minimapCtx.beginPath();
                        this.minimapCtx.arc(
                            centerX + dx * scale,
                            centerY + dy * scale,
                            5,
                            0,
                            Math.PI * 2
                        );
                        this.minimapCtx.fill();
                    }
                });

                // Draw player
                this.minimapCtx.fillStyle = '#fff';
                this.minimapCtx.fillRect(centerX - 3, centerY - 3, 6, 6);

                // Draw player direction indicator
                this.minimapCtx.strokeStyle = '#fff';
                this.minimapCtx.lineWidth = 2;
                this.minimapCtx.beginPath();
                this.minimapCtx.moveTo(centerX, centerY);
                const dirX = this.player.facing === 'east' ? 1 : this.player.facing === 'west' ? -1 : 0;
                const dirY = this.player.facing === 'south' ? 1 : this.player.facing === 'north' ? -1 : 0;
                this.minimapCtx.lineTo(centerX + dirX * 8, centerY + dirY * 8);
                this.minimapCtx.stroke();
            }

            updateUI() {
                // Health
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = 
                    `${Math.floor(this.player.health)}/${this.player.maxHealth}`;

                // Mana
                const manaPercent = (this.player.mana / this.player.maxMana) * 100;
                document.getElementById('manaBar').style.width = manaPercent + '%';
                document.getElementById('manaText').textContent = 
                    `${Math.floor(this.player.mana)}/${this.player.maxMana}`;

                // Experience
                const expPercent = (this.player.exp / this.player.expToNext) * 100;
                document.getElementById('expBar').style.width = expPercent + '%';
                document.getElementById('expText').textContent = 
                    `${this.player.exp}/${this.player.expToNext}`;

                // Level and gold
                document.getElementById('playerLevel').textContent = this.player.level;
                document.getElementById('playerGold').textContent = this.player.gold;
            }

            renderInventory() {
                const grid = document.getElementById('inventoryGrid');
                grid.innerHTML = '';

                for (let i = 0; i < 28; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot';

                    if (this.player.inventory[i]) {
                        const item = this.player.inventory[i];
                        slot.innerHTML = item.icon || 'üì¶';
                        slot.title = item.name;
                        
                        slot.onclick = () => this.useItem(i);
                    }

                    grid.appendChild(slot);
                }
            }

            useItem(index) {
                const item = this.player.inventory[index];
                if (!item) return;

                this.addAIMessage(`Used ${item.name}`, 'system');
                
                // AI determines item effect
                this.callAI(`Player uses item: ${item.name}`, 'item').then(response => {
                    if (response && response.assistant_response) {
                        this.addAIMessage(response.assistant_response, 'system');
                    }
                });

                this.player.inventory.splice(index, 1);
                this.renderInventory();
            }

            updateQuestTracker() {
                const list = document.getElementById('questList');
                list.innerHTML = '';

                this.activeQuests.filter(q => !q.completed).slice(0, 5).forEach(quest => {
                    const item = document.createElement('div');
                    item.className = 'quest-item';
                    item.innerHTML = quest.name;
                    list.appendChild(item);
                });
            }

            toggleInventory() {
                const inv = document.querySelector('.inventory');
                inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
            }

            darkenColor(color, amount) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.floor((num >> 16) * amount);
                const g = Math.floor(((num >> 8) & 0x00FF) * amount);
                const b = Math.floor((num & 0x0000FF) * amount);
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }

            shiftColor(color, amount) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.min(255, (num >> 16) + amount);
                const g = Math.min(255, ((num >> 8) & 0x00FF) + amount);
                const b = Math.min(255, (num & 0x0000FF) + amount);
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }

            showLoadingProgress(percent, text) {
                document.getElementById('loadingFill').style.width = percent + '%';
                document.querySelector('.loading-text').textContent = text;
            }

            hideLoading() {
                const loading = document.getElementById('loadingScreen');
                loading.style.opacity = '0';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.minimapCanvas.width = 200;
                this.minimapCanvas.height = 200;
            }

            gameLoop(timestamp) {
                this.deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.gameTime = timestamp;

                this.update(this.deltaTime);
                this.render();

                requestAnimationFrame((t) => this.gameLoop(t));
            }
        }

        // Initialize the AI-enhanced game
        const game = new AIRunecraft3D();
    </script>
</body>
</html>